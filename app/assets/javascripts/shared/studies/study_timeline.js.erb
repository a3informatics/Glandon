/*
* Study Timeline
*
* Only in Study Build page
*/

/**
 * Study Timeline Constructor
 *
 * @param armId [String] id of the arm to which this instance belongs
 * @param matrixRef [Object Instance] reference to the parent matrix instance
 * @return [void]
 */
function StudyTimeline(armId, matrixRef) {
  this.armId = armId;
  this.matrix = matrixRef;
  this.ready = false;
  this.interactive = true;

  this.tabName = "tab-timeline";
  this.wrapper = $("#tab-timeline-body");
  this.div = this.wrapper.find("#study-timeline");

  this.tpRadius = 24;
  this.tpDialog = new ContextDialog("0");

  this.data = { timepoints: [], renderTimepoints: [] }
}


/**
 ************** General **************
**/


/**
 * Shows timeline
 *
 * @return [void]
 */
StudyTimeline.prototype.show = function() {
  if (this.ready)
    this.render(this.data.timepoints);
  else
    this.loadData();
}

/**
 * Loads timeline data
 *
 * @return [void]
 */
StudyTimeline.prototype.loadData = function() {
  this.loading(true);

  this.matrix.executeRequest({
    url: this.tpDataUrl(),
    type: "GET",
    data: {},
    withLoading: false,
    callback: function(result) {
      $.each(result.data, function(i, timepoint) {
        this.data.timepoints.push(new Timepoint(timepoint, this.matrix, this));
      }.bind(this));

      this.ready = true;
      this.loading(false);
      this.render(this.data.timepoints);
    }.bind(this)
  })
}

/**
 * Sets event listeners and handlers
 *
 * @return [void]
 */
StudyTimeline.prototype.setListeners = function() {
  this.div
    .off("dblclick", ".timepoint")
    .on("dblclick", ".timepoint", function(e) {
      this.findTimepoint("id", $(e.currentTarget).attr("data-id")).openTpContextDialog();
    }.bind(this));

  if(this.interactive)
    this.interactionListeners();
}


/**
 * Sets event listeners and handlers
 *
 * @return [void]
 */
StudyTimeline.prototype.minMaxOffsets = function() {
  this.data.renderTimepoints.sort((a, b) => (a.data.offset > b.data.offset) ? 1 : -1)

  var maxOffset = Math.max.apply(Math, this.data.renderTimepoints.map(function(t) { return t.data.offset; }));
  var minOffset = Math.min.apply(Math, this.data.renderTimepoints.map(function(t) { return t.data.offset; }));
  // Add 5% buffer for the right edge of the timeline
  maxOffset += 5;

  this.maxOffset = maxOffset;
  this.minOffset = minOffset;
}

/**
 * Timeline interaction event handlers
 *
 * @return [void]
 */
StudyTimeline.prototype.interactionListeners = function() {
  var _this = this;

  $(this.div).find(".epoch-block").resizable({
    handles: "w,e",
    containment: $("#tl-wrapper"),
    minWidth: 20,
    alsoResizeReverse: $(this.div).find('.epoch-block'),
    resize: function(ev, ui) {
      $.each(_this.data.renderTimepoints, function(i, timepoint) {
        timepoint.updateTpEpoch();
      });
    },
    stop: function(ev, ui){
      this.render(this.data.renderTimepoints);
    }.bind(this)
  });

  $(_.first($(this.div).find(".epoch-block"))).find(".ui-resizable-handle.ui-resizable-w").remove();
  $(this.div).find(".epoch-block").find(".ui-resizable-handle.ui-resizable-e").remove();


  $(this.div).find(".timepoint").draggable({
    axis: "x",
    cancel: ".baseline",
    containment: [$("#tl-wrapper").offset().left - 40, 0, $("#tl-wrapper").offset().left + $("#tl-wrapper").width() + 20, 0],
    start: function (e, ui) {
      this.minMaxOffsets();
    }.bind(this),
    drag: function(e, ui) {
      var timepoint = this.findTimepoint("id", $(e.target).attr("data-id"));
      timepoint.updateTpEpoch();
      timepoint.updateTpOffset();
    }.bind(this),
    stop: function (e, ui) {
      this.render(this.data.renderTimepoints);
    }.bind(this),
  });

  $(window).on("resize", function(){
    $(this.div).find(".epoch-block").resizable("option", "containment", $("#tl-wrapper"));
    $(this.div).find(".timepoint").draggable("option", "containment", [$("#tl-wrapper").offset().left - 40, 0, $("#tl-wrapper").offset().left + $("#tl-wrapper").width() + 20, 0]);
  });

  $(this.wrapper).find(".visit").draggable({
    opacity: 0.8,
    helper: "clone",
    revertDuration: 100,
    revert: true,
    start: function(ev, ui) {
      _this.desaturate(true);
    },
    stop: function(ev, ui) {
      _this.desaturate(false);
    }
  });

  $(this.wrapper).find(".timepoint").droppable({
    accept: ".visit",
    drop: function(ev, ui) {
      var timepointId = $(this).attr("data-id");
      var visitId = ui.draggable.attr("data-id");
      _this.matrix.getItem(visitId, "visits").addTimepoints([timepointId]);
    }
  });
}

/**
 * Renders timeline based on a set of timepoints
 *
 * @param timepointSet [Array] set or subset of timepoint data objects to render
 * @return [void]
 */
StudyTimeline.prototype.render = function(timepointSet) {
  this.data.renderTimepoints = timepointSet;
  this.clear();
  this.div.addClass("fadein");

  this.div.append("<div id='tl-wrapper'></div>");
  var wrap = this.div.find("#tl-wrapper");

  wrap.append(this.axisHTML());

  $.each(timepointSet, function(index, timepoint) {
    wrap.append(timepoint.timepointHTML());
  }.bind(this));

  var epochs = this.matrix.data.epochs;
  $.each(_.values(epochs), function(index, epoch){
    wrap.append(this.epochHTML(epoch));
  }.bind(this));

  var visits = this.matrix.data.visits;
  $.each(_.values(visits), function(index, visit){
    wrap.append(visit.blockHTML());
  }.bind(this));

  setTimeout(function(){this.div.removeClass("fadein")}.bind(this), 1);

  this.setListeners();
}


/**
 ************** Timepoint Details **************
**/


/**
 * Remove a BC from a timepoint request, UI update
 *
 * @return [void]
 */
StudyTimeline.prototype.removeBCFromTp = function(e) {
  var wrapper = $(e.currentTarget).closest(".timepoint-details");
  var bcId = $(e.currentTarget).attr("data-id");

  $(e.currentTarget).remove();
}

/**
 * Show selector dialog, add BCs to a timepoint request, UI update
 *
 * @return [void]
 */
StudyTimeline.prototype.addBCToTp = function(e) {
  var _this = this;
  var wrapper = $(e.currentTarget).closest(".timepoint-details");

  this.matrix.bcsSelector.setCallback(function(data) {
    $.each(data.bcs, function(idx, bc) {
      // TODO: Add server request to post data
      // TODO: Handle server response on added BCs (re-draw the dialog)
      wrapper.find(".bg-labels-wrap")
        .append("<span class='bg-label removable' data-id='"+ bc.id +"'>"+
                  _this.bcLabel(bc) +
                "</span>");
    });
  })

  this.matrix.bcsSelector.show();
}



/**
 ************** HTML **************
**/


/**
 * Generates HTML for the axis
 *
 * @return [String] Styled axis HTML
 */
StudyTimeline.prototype.axisHTML = function() {
  var arm = this.matrix.getItem(this.armId, "arms");

  var axisColor = this.matrix.hslString(arm.color),
      axisLabel = "<div class='axis-label' style='color: "+ axisColor +"'>" +
                    arm.label +
                  "</div>";

  return "<div id='timeline-axis' style='background-color: " + axisColor + "'>" +
            axisLabel +
         "</div>";
}


/**
 * Generates HTML for an epoch on the timeline
 *
 * @param epoch [Object] single epoch object
 * @return [String] epoch HTML to be appended to timeline
 */
StudyTimeline.prototype.epochHTML = function(epoch) {
  var epochCSS = this.getEpochCSS(epoch);

  if(_.isNull(epochCSS))
    return "";

  var style = "background-color: " + epochCSS.bgColor + "; " +
              "left: " + epochCSS.offsetLeft + "; " +
              "width: " + epochCSS.width + ";";

  var content = "<div class='epoch-label' style='color: "+ epochCSS.labelColor +"'>" +
                  epoch.label +
                "</div>";

  // HTML to Render
  return "<div class='epoch-block' style='"+ style +"' data-epoch-id='"+epoch.id+"'>" +
            content +
         "</div>";
}

/**
 * Makes a CSS width string for an epoch, based on various conditions
 *
 * @param epoch [Object] single epoch object
 * @param edgeTimepoints [Array] edge timepoints calculated by getEpochEdgeTps
 * @return [String] CSS Width string for an Epoch HTML / null if no epoch data
 */
StudyTimeline.prototype.getEpochCSS = function(epoch) {
  var edgeTimepoints = this.getEpochEdgeTps(epoch);

  // No timepoints in an epoch - do not render
  if (_.isEmpty(edgeTimepoints))
    return null;

  var epochBgColor = this.matrix.hslString({h: epoch.color.h, s: epoch.color.s - 10, l: epoch.color.l + 12 }),
      epochLabelColor = this.matrix.hslString({h: epoch.color.h, s: epoch.color.s - 10, l: epoch.color.l - 40 }),
      epochWidth, epochOffsetLeft;

  // No next timepoint after epoch
  if (_.isUndefined(edgeTimepoints[1])) {
    var lastTimepoint = _.last(this.data.renderTimepoints);

    // First and last timepoints are the same
    if (lastTimepoint.data.id == edgeTimepoints[0].id)
      epochWidth = "calc(100% - " + lastTimepoint.offsetLeft + "%)";
    // First and last timepoints are not the same - find difference
    else {
      var difference = lastTimepoint.offsetLeft - edgeTimepoints[0].offsetLeft;
      epochWidth = "calc(100% - " + edgeTimepoints[0].offsetLeft +"%)";
    }
  }
  else {
    // Difference between first epoch timepoint and first next epoch timepoint
    var difference = edgeTimepoints[1].offsetLeft - edgeTimepoints[0].offsetLeft;
    epochWidth = difference + "%";
  }

  epochOffsetLeft = "calc(" + edgeTimepoints[0].offsetLeft + "%)" || "0";

  return {
    bgColor: epochBgColor,
    labelColor: epochLabelColor,
    width: epochWidth,
    offsetLeft: epochOffsetLeft
  };
}

/**
 * Finds first timepoint belonging to an epoch, and the first timepoint of the next epoch
 *
 * @param epoch [Object] single epoch object
 * @return [Array] [0] first epoch timepoint, [1] first next epoch timepoint / null
 * returns empty [] if no timepoints found
 */
StudyTimeline.prototype.getEpochEdgeTps = function(epoch) {
  var epochTimepoints = _.filter(this.data.renderTimepoints, function (tp) { return tp.data.epoch_id == epoch.id; }),
      nextTimepointIndex = _.indexOf(this.data.renderTimepoints, _.last(epochTimepoints)) + 1;
      nextTimepoint = this.data.renderTimepoints[nextTimepointIndex];

  if (_.isEmpty(epochTimepoints))
    return [];

  return [epochTimepoints[0], nextTimepoint];
}

/**
 * Finds previous epoch
 *
 * @param epoch [Object] single epoch object
 * @return
 */
StudyTimeline.prototype.getPreviousEpoch = function(epoch) {
  var index = _.indexOf(epoch, _.values(this.data.epochs)) - 1;

  return _.values(this.data.epochs)[index];
}


/**
 ************** Support **************
**/


/**
 * Filters timepoints based on a value
 *
 * @param paramType [String] name of the property to filter on
 * @param value [String] value to compare
 * @return [Array] filtered array of this instance's timepoint data
 */
StudyTimeline.prototype.filterTimepoints = function(paramType, value) {
  return this.data.timepoints.filter( function(tp) { return tp.data[paramType] == value });
}

/**
 * Finds a timepoint based on the parameters
 *
 * @param property [String] property type (eg id)
 * @param value [Anything] value to compare
 * @return [Object] first timepoint matching / null if not found
 */
StudyTimeline.prototype.findTimepoint = function(property, value) {
  var result = null;

  $.each(this.data.timepoints, function(index, timepoint) {
    if (timepoint.data[property] == value) {
      result = timepoint;
      return false;
    }
  });

  return result;
}

/**
 * Get TP data url for this arm
 *
 * @return [String] url for data fetch
 */
StudyTimeline.prototype.tpDataUrl = function() {
  return timepointsArmUrl.replace("armId", this.armId);
}

/**
 * Get TP add url for this arm
 *
 * @return [String] url for timepoint add
 */
StudyTimeline.prototype.tpAddUrl = function() {
  return addTimepointUrl.replace("armId", this.armId);
}


/**
 * Toggles desaturation overlay
 *
 * @param enable [Boolean] true / false enable / disable overlay
 * @param zIndex [Integer] optional
 * @return [void]
 */
StudyTimeline.prototype.desaturate = function(enable, zIndex) {
  if (enable)
    $(this.wrapper).append("<div class='dark-overlay' style='z-index: "+ (zIndex || 9) +"'></div>");
  else
    $(".dark-overlay").remove();
}

/**
 * Clears timeline
 *
 * @return [void]
 */
StudyTimeline.prototype.clear = function() {
  this.div.empty();
  this.tpDialog.clear();
  this.minMaxOffsets();
}


/**
 * Sets event listeners and handlers
 *
 * @param enable [Boolean] enable or disable loading
 * @return [void]
 */
StudyTimeline.prototype.loading = function(enable) {
  this.matrix.armLoading(this.armId, enable)
}

/**
 * Generates HTML for the axis
 *
 * @param [Object] Timepoints data object
 * @return [String] Styled axis HTML
 */
StudyTimeline.prototype.bcLabel = function(bc) {
  return bc.label + " (" + (bc.identifier || bc.has_identifier.identifier) + ") v" + (bc.semantic_version || "0.1.0");
}

/**
 * Converts x-axis offset to days offset relative to timepoints and timeline width
 *
 * @param offset [Int] X offset on the timeline
 * @return [Int] Offset in days
 */
StudyTimeline.prototype.offsetToDays = function(offset) {
  var width = $("#tl-wrapper").width(),
      offset = Math.floor(offset / (width / (this.maxOffset - this.minOffset))) + this.minOffset;

  return offset;
}

/**
 * Finds closest epoch to an offset on the x axis
 *
 * @param offset [Int] X-axis offset to find epoch for
 * @return [String] closest epoch element id / empty ""
 */
StudyTimeline.prototype.offsetClosestEpoch = function(offset) {
  var tEpoch = null;

  $(".epoch-block").each(function(i, e) {
    var eLeft = $(e).position().left,
        eRight = $(e).position().left + $(e).width();

    if ((eLeft < offset) && (eRight > offset)) {
      tEpoch = $(e);
      return false;
    }
  });

  if(tEpoch == "") {
    $(".epoch-block").each(function(i, e) {
      if (tEpoch == null)
        tEpoch = $(e);
      else {
        var eLeft = $(e).position().left,
            tELeft = $(tEpoch).position().left;

        if (Math.abs(eLeft - offset) <= Math.abs(tELeft - offset))
          tEpoch = $(e);
      }
    });
  }

  return tEpoch.attr("data-epoch-id");
}
